package veritas

import org.reflections.Reflections

import java.nio.file.{Files, Path}
import scala.collection.convert.ImplicitConversions._
import scala.collection.immutable.ListMap

/**
 * Generates a simple coverage report indicating which case classes inheriting from [[Expr]] are being used by
 * the tests.
 */
object Coverage {
  private val reflections = new Reflections("scala")
  // Put names of redundant expressions here so they are ignored in the report (such as "Ident")
  private val redundantExprs: List[String] = List()
  private var exprs: List[List[ExprUsages]] = List()
  private var percentage = -1.0

  /**
   * Calculates the case classes the given expression covers and saves it for later.
   *
   * @param expr Parsed code
   */
  def AddCoverage(expr: Expr): Unit = this.synchronized {
    this.exprs = this.exprs ::: List(GetExprs(expr))
  }

  /**
   * Returns the list of [[Expr]] case classes used in the given expression along with their counts.
   *
   * @param expr The expression
   * @return List[ClassName, Count]
   */
  private def GetExprs(expr: Expr): List[ExprUsages] = {
    val exprs = GetExprClassNameTuples

    val tmp = expr.toString
      .split(",").flatMap(el =>
      el
        .replaceAll("[()]", "\n")
        .split("\n")
        .map(_.trim)
        .filterNot(el => el.isEmpty || el == "List")
        .filterNot(redundantExprs.contains(_))
    )

    exprs
      .filter(el => tmp.contains(el._2))
      .map(el => ExprUsages(el._2, tmp.count(_ == el._2)))
  }

  /**
   * Get the list of case classes inheriting from [[Expr]] along with their names.
   *
   * @return (Class,ClassName) tuples
   */
  private def GetExprClassNameTuples: List[(Class[_ <: Expr], String)] = {
    reflections.getSubTypesOf(classOf[Expr]).toList
      .map(el => (el, el.getName.split("\\$").last))
  }

  /**
   * Generates a map between each case class and the amount of times they were used in the tests.
   *
   * @param export True exports a CodeCov JSON report
   * @return Map[ClassName, TimesUsed]
   */
  def CalculateCoverage(export: Boolean = false): Map[String, Int] = {
    val coverages = SumCoverages(exprs)

    val res = GetAllExprCaseClasses()
      .groupBy(identity)
      .map(el => el._1 -> 0)
      .filterNot(el => redundantExprs.contains(el._1))

    percentage = ((coverages.size / GetAllExprCaseClasses().size.toDouble) * 100).round

    println(s"==== Covered $percentage% of Expr case classes ====\n")

    val output = ListMap.from((res ++ coverages).toSeq.sortBy(_._2))

    if (export)
      CreateCodeCovReport(output)

    output
  }

  /**
   * Sums a list of results generated by the [[GetExprs]] the method; turns them into a map and sums the class usages.
   *
   * @param args List of `GetExprs` results
   * @return Map[ClassName, TimesUsed]
   * @note I'm bad at explaining. The difference between this and [[CalculateCoverage]] is that this method
   *       only includes used case classes in the return while the other one includes all of them (the rest just
   *       with a count of zero)
   */
  private def SumCoverages(args: List[List[ExprUsages]]): Map[String, Int] = {
    args
      .flatten
      .map(el => (el.Expression, el.TimesUsed))
      .groupBy(_._1)
      .map(el => el._2.reduce((op, x) => (op._1, op._2 + x._2)))
  }

  /**
   * Gets all case classes inheriting from [[Expr]]
   *
   * @return List of class names.
   */
  private def GetAllExprCaseClasses(): List[String] = {
    classOf[Expr]
      .getDeclaredClasses
      .map(el => el.getName.split("\\$").last)
      .distinct
      .toList
  }

  /**
   * Creates a CodeCov report and exports it to `coverage.json`.
   *
   * @param cov Calculated coverage from [[CalculateCoverage]].
   */
  private def CreateCodeCovReport(cov: Map[String, Int]): Unit = {
    var output: List[ExprUsagesLine] = List()
    val txt = Files.readAllLines(Path.of("src/main/scala/scala/Definitions.scala"))

    // Find where the object starts to avoid mismatching stuff with imports
    // This shouldn't happen because of the regex stuff I later added below but
    // you never know.
    val objStart = txt.indexWhere(_.contains("object Expr"))

    cov.foreach(el => output = output :+
      ExprUsagesLine(el._1, el._2,
        txt
          .drop(objStart)
          .indexWhere(line => ExtractClassName(line) == el._1) + objStart + 1
      ))

    val start = "{\"coverage\":{\"app/src/main/scala/scala/Definitions.scala\": {"
    val end = "}}}"
    val json = start + output.map(el => s"\"${el.Line}\": ${el.TimesUsed},").mkString.dropRight(1) + end

    try {
      Files.writeString(Path.of("../coverage.json"), json)
      println("Coverage report exported successfully!\n")
    } catch {
      case e: Exception => println(s"Exporting coverage failed with $e")
    }
  }

  /**
   * Extracts the case class name from any `Definitions.scala` line.
   *
   * @param line The line.
   * @return The case class name.
   */
  private def ExtractClassName(line: String): String = {
    val data = "case class ([a-zA-Z]+)\\(".r.findAllIn(line).matchData.toList
    if (data.isEmpty) ""
    else data.get(0).group(1)
  }

  /**
   * Helper class.
   *
   * @param Expression The [[Expr]] class in question.
   * @param TimesUsed  The amount of times it was used in the tests.
   * @param Line       The line number from `Definitions.scala`.
   */
  private case class ExprUsagesLine(Expression: String, TimesUsed: Int, Line: Int)

  /**
   * Helper class.
   *
   * @param Expression The [[Expr]] class in question.
   * @param TimesUsed  The amount of times it was used in the tests.
   */
  private case class ExprUsages(Expression: String, TimesUsed: Int)
}